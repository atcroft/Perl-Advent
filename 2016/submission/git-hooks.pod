Title: Writing git hooks with Git::Hooks
Topic: Git::Hooks
Author: JMERELO <JMERELO@cpan.org>

=pod

=encoding utf8

=head1 Let's start with the hooks.

You are a developer, you are probably using git. You are using git,
you are probably using hooks too. I<hooks> are programs triggered by a
certain event in a git repo. You can find examples stashed in the
C<.git/hooks> directory. They are there just for the show, and they
are not used by default. However, it is very likely that if you use
some remote repository like GitHub or GitLab, this one might actually
be using these hooks to rebuild web pages, trigger deployments or
myriad other stuff. Both GitHub and GitLab allow us to configure them
quite easily via web.

However, the point of this article is to show you how to write them
yourself. So let's first find out what kind of events can trigger a
hook. The whole list is L<in the Git reference
page|https://git-scm.com/docs/githooks> and, in the last git version,
includes 19 different events. 

We can divide them in different ways; for instance, according to
I<when> they actually happen. C<pre> and C<post> happen before and
after a particular git command; for instance, C<pre-commit> hooks
happen before the actual commit, that is, before the actually commit
message is read. These C<pre> hooks can be used to implement policies
at the client level and can return a value that will indicate that the
particular action has failed; for instance, if a commit message
contains typos or fails company policy in some other way. There's even
a C<prepare> hook that happens right before the C<pre> hook is
triggered: C<prepare-commit-message>. On the other hand, C<post> hooks
do not affect the command itself, just the way the repository is
arranged after the command is run. A C<post-receive> hook, for
instance, can send an email to the user or administrator when a push
has been processed on a remote repository, or send a message to a
continous integration server, or trigger a rebuild of the web site. 

On the other hand, they can also be divided according to the git
command that triggers them. Four of them, are related to
C<commit>, others to C<am>, and yet others to C<push> and to
C<receive-pack>, a I<plumbing> command run when a push is received in
a repository. 

=head2 Now that we mention plumbing

Writing hooks involves diving into the depths of git, going, so to
say, into the plumbing. In fact, git commands are divided, using a
toilette metaphor, into two classes: I<porcelain> and I<plumbing>. It
is L<not too clear which is
which|http://stackoverflow.com/questions/39847781/which-are-the-plumbing-and-porcelain-commands/39848056>,
the division being "what can be seen from outside" (porcelain) and
"what is used from there" (plumbing). According to that, most of the
stuff we use, clone, add, commit and so on, are "porcelain". And most
of the stuff you do not I<usually> run is plumbing: C<git-unpack-file>
or C<git-read-tree> is not the kind of thing you usually run from th
command line. However, this is precisely the kind of commands we are
going to run from our hooks. 

=head2 And plumbing works on the pipes.

Or, actually, the trees. Let's again L<get back to
basics|https://git-scm.com/book/ch1-3.html#The-Three-States> and study
the three states of a project in git: working directory, also called
I<working tree>, staging area and the C<.git> directory. In a nutshell,
C<add> adds files to the staging area, sometimes called for no reason
whatsoever I<index>, C<commit> passes them through to the C<.git>
directory, and C<checkout> takes them back from the C<.git> to the
working directory.

But the plumbing area is full of
trees. L<Trees|https://git-scm.com/book/es/v2/Git-Internals-Git-Objects#Tree-Objects>
are used to store directories with the files and other directories,
also stored as trees, in them. This is an efficient, packed way of
storing content; git is actually a content-addressable file
system. Which is great. But takes us away from the simple concept of
a-source-control-management-system-storing-changes-and-that's-it. 

The good news about this is that git allows us to work easily, through
plumbing commands, with the internal structure. Bad news is that we
pretty much need to know how to program our own git in order to write
a good hook.

=head1 Which takes us back to writing hooks.

As said above, hooks are simply scripts. They can be as simple as a
shell script or as complicated as a REST client consuming an API. In
general, a hook will work this way

=over 4

=item Check out stuff

 Look at what's going on. Check out its inputs and use them to
dig a bit deeper using plumbing commands, set the stage.

=item Work

Do the real work. Change log messages, rearrange files or create
new ones, do lots of different things.

=item Return

Return, possibly with a message, including an failure or success
message if it is a C<pre>-class hook. 

=back



=head1 SEE ALSO

=for :list
* L<Bencher>
* L<Bencher::Scenario::LevenshteinModules>

=cut
